{"version":3,"sources":["webpack:///./node_modules/mezr/mezr.js"],"names":["global","factory","this","undefined","win","document","self","defaultView","window","doc","root","documentElement","body","Error","tempBCR","abs","Math","max","min","edges","content","padding","scroll","border","margin","unscrollableDisplayValues","settings","getWidth","el","edge","getDimension","getHeight","getOffset","Array","isArray","elemA","concat","elemB","offsetA","isPlainObject","getOffsetFromDocument","offsetB","left","top","getRect","rect","getRectInternal","offsetFrom","getContainingBlock","fakePosition","ret","scrollProps","parent","style","i","position","getStyle","transformLeaksFixed","parentElement","isTransformed","parentNode","getDistance","a","b","aRect","getSanitizedRect","bRect","getIntersection","getDistanceBetweenRects","getIntersectionMultiple","intersection","arguments","length","getOverflow","elA","elB","getOverlap","right","bottom","getPlace","options","cRect","overlap","eCurrentOffset","opts","mergeObjects","placeDefaultOptions","split","eRect","element","tRect","target","isContainDefined","contain","container","within","overflowAction","getOverflowAction","onOverflow","overflowFixLeft","overflowFixTop","offsetX","offsetY","indexOf","toFloat","width","height","getPlacePosition","getPlaceOverflowPush","adjust","apply","elementRect","targetRect","containerRect","shift","overflow","overflowCorrection","val","Object","prototype","toString","call","getSupportedTransform","transforms","prop","prefix","toLowerCase","propName","styleName","doesTransformLeakFixed","transform","leftNotTransformed","leftTransformed","outer","createElement","inner","setStyles","display","visibility","appendChild","getBoundingClientRect","removeChild","parseFloat","array","propVal","len","hasOwnProperty","slice","getComputedStyle","getPropertyValue","getStyleAsFloat","styles","keys","forEach","intWidth","intHeight","hasIntersection","getDistanceBetweenPoints","aLeft","aTop","bLeft","bTop","sqrt","pow","rectA","rectB","aRight","aBottom","bRight","bBottom","dimension","includePadding","includeScrollbar","includeBorder","includeMargin","edgeA","edgeB","borderA","borderB","marginA","marginB","isHeight","dimensionCapitalized","innerDimension","clientDimension","scrollDimension","sbSize","round","pageXOffset","pageYOffset","gbcr","marginLeft","marginTop","useStaticOffset","isElem","getStaticOffset","offset","elementPosition","targetPosition","targetSize","targetOffset","elementSize","elementNwOffset","extraOffset","placement","charAt","northwestPoint","overflowConfig","targetOverlap","isVertical","push","forcePush","sideA","sideB","sideAConfig","sideBConfig","sideAOverlap","sideBOverlap","sizeDifference","actionType","x","y","containingBlock","distance","place","_settings"],"mappings":"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","file":"js/chunk-2d2384d4.bd186c63.js","sourcesContent":["/*!\n * mezr v0.6.2\n * https://github.com/niklasramo/mezr\n * Copyright (c) 2016 Niklas Rämö <inramo@gmail.com>\n * Released under the MIT license\n */\n\n(function (global, factory) {\n\n  if (typeof define === 'function' && define.amd) {\n    define([], function () {\n      return factory(global);\n    });\n  }\n  else if (typeof module === 'object' && module.exports) {\n    module.exports = factory(global);\n  }\n  else {\n    global.mezr = factory(global);\n  }\n\n}(this, function (global, undefined) {\n\n  'use strict';\n\n  // Make sure we received a valid window object from the arguments.\n  var win = global.document && global.self === global.document.defaultView ? global : window;\n\n  // Cache document, root and body elements.\n  var doc = win.document;\n  var root = doc.documentElement;\n  var body = doc.body;\n\n  // Throw error if body is not available\n  if (!body) {\n    throw Error('Mezr needs access to body element.');\n  }\n\n  // Cache some often used native functions.\n  var abs = Math.abs;\n  var max = Math.max;\n  var min = Math.min;\n\n  // String to number mappings for element edges.\n  var edges = {\n    content: 1,\n    padding: 2,\n    scroll: 3,\n    border: 4,\n    margin: 5\n  };\n\n  // CSS display values which make it impossible for an element to have a\n  // scrollbar.\n  var unscrollableDisplayValues = ['inline', 'table-column', 'table-column-group'];\n\n  // Temporary bounding client rect data.\n  var tempBCR;\n\n  // Mezr settings.\n  var settings = {};\n\n  // Default options for place method.\n  settings.placeDefaultOptions = {\n    element: null,\n    target: null,\n    position: 'left top left top',\n    offsetX: 0,\n    offsetY: 0,\n    contain: null,\n    adjust: null\n  };\n\n  // Get the primary supported transform property.\n  settings.transform = getSupportedTransform();\n\n  // Check if transformed elements leak fixed elements? According W3C\n  // specification (about transform rendering) a transformed element should\n  // contain fixed elements, but not every browser follows the spec. So we need\n  // to test it.\n  settings.transformLeaksFixed = doesTransformLeakFixed();\n\n  /**\n   * Public methods\n   * **************\n   */\n\n  /**\n   * Returns the width of an element in pixels. Accepts also the window object\n   * (for getting the viewport width) and the document object (for getting the\n   * document width) in place of element.\n   *\n   * @example\n   * mezr.width(elemA, 'content');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getWidth(el, edge) {\n\n    edge = edge && edges[edge] || 4;\n\n    return getDimension('width', el, edge > 1, edge > 2, edge > 3, edge > 4);\n\n  }\n\n  /**\n   * Returns the height of an element in pixels. Accepts also the window object\n   * (for getting the viewport height) and the document object (for getting the\n   * document height) in place of element.\n   *\n   * @example\n   * mezr.height(elemA, 'content');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getHeight(el, edge) {\n\n    edge = edge && edges[edge] || 4;\n\n    return getDimension('height', el, edge > 1, edge > 2, edge > 3, edge > 4);\n\n  }\n\n  /**\n   * Returns the element's offset from another element, window or document. In\n   * practice the offset means the vertical and horizontal distance from the\n   * comparison element's northwest corner to the target element's northwest\n   * corner. By default the comparison element is considered to be the document.\n   *\n   * @example\n   * // Returns offset from document's northwest corner to elemA's content\n   * // layer's northwest corner.\n   * mezr.offset(elemA, 'content');\n   *\n   * @example\n   * // Returns offset from window's northwest corner to elemA's content layer's\n   * // northwest corner.\n   * mezr.offset([elemA, 'content'], window);\n   *\n   * @example\n   * // Returns offset from elemB's margin layer's northwest corner to elemA's\n   * // content layer's northwest corner.\n   * mezr.offset([elemA, 'padding'], [elemB, 'margin']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Rectangle|Window)} el\n   * @param {(Array|Document|Edge|Element|Rectangle|Window)} [edge='border']\n   *   - If this argument is a string it is considered to be an edge layer\n   *     definition for the first argument. Otherwise this is considered to be a\n   *     defintion of an element, document or window.\n   * @returns {Offset}\n   */\n  function getOffset(el, edge) {\n\n    // Use default syntax if the element is not an array and the edge is\n    // undefined or a string.\n    if (!Array.isArray(el) && (!edge || typeof edge === 'string')) {\n      return getOffsetFromDocument(el, edge);\n    }\n\n    // Otherwise assume that two element/document/window defintions were\n    // provided and calculate the offset from the second to the first element.\n    else {\n\n      var elemA = [].concat(el);\n      var elemB = [].concat(edge);\n      var offsetA = isPlainObject(el) ? el : getOffsetFromDocument(elemA[0], elemA[1]);\n      var offsetB = isPlainObject(edge) ? edge : getOffsetFromDocument(elemB[0], elemB[1]);\n\n      return {\n        left: offsetA.left - offsetB.left,\n        top: offsetA.top - offsetB.top\n      };\n\n    }\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically a helper method for calculating an element's dimensions\n   * and offsets simultaneously. Mimics the native getBoundingClientRect method\n   * with the added bonus of allowing to provide the \"edge\" of the element.\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"content\" layer in the\n   * // calculations) with the offset calculated from the document.\n   * mezr.offset(elemA, 'content');\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"content\" layer in the\n   * // calculations) with the offset calculated from the window.\n   * mezr.rect([elemA, 'content'], window);\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"padding\" layer in the\n   * // calculations) with the offset calculated from the elemB (\"margin\"\n   * // layer).\n   * mezr.rect([elemA, 'padding'], [elemB, 'margin']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Rectangle|Window)} el\n   * @param {(Array|Document|Edge|Element|Rectangle|Window)} [edge='border']\n   *   - If this argument is a string it is considered to be an edge layer\n   *     definition for the first argument. Otherwise this is considered to be a\n   *     defintion of an element, document or window.\n   * @returns {Rectangle}\n   */\n  function getRect(el, edge) {\n\n    // Use default syntax if the element is not an array and the edge is\n    // undefined or a string.\n    if (!Array.isArray(el) && (!edge || typeof edge === 'string')) {\n      return getRectInternal(el, edge);\n    }\n\n    // Otherwise assume that two element/document/window defintions were\n    // provided and calculate the offset from the second to the first element.\n    else {\n\n      var elemA = [].concat(el);\n      var elemB = [].concat(edge);\n      var rect = isPlainObject(el) ? el : getRectInternal(elemA[0], elemA[1]);\n      var offsetFrom = isPlainObject(edge) ? edge : getOffsetFromDocument(elemB[0], elemB[1]);\n\n      rect.left = rect.left - offsetFrom.left;\n      rect.top = rect.top - offsetFrom.top;\n\n      return rect;\n\n    }\n\n  }\n\n  /**\n   * Returns the element's containing block, which is considered to be the\n   * closest ancestor element (or window, or document, or the target element\n   * itself) that the target element's positioning is relative to. In other\n   * words, containing block is the element the target element's CSS properties\n   * \"left\", \"right\", \"top\" and \"bottom\" are relative to. You should not confuse\n   * this with the native elem.offsetParent read-only property, which works in a\n   * similar fashion (and even identically in certain situations), but is really\n   * not the same thing (although the name might imply it).\n   *\n   * The logic:\n   * - Document is considered to be the root containing block of all elements\n   *   and the window. Getting the document's containing block will return null.\n   * - Static element does not have a containing block since setting values to\n   *   the \"left\", \"right\", \"top\" and \"bottom\" CSS properties does not have any\n   *   effect on the element's position. Thus, getting the containing block of a\n   *   static element will return null.\n   * - Relative element's containing block is always the element itself.\n   * - Fixed element's containing block is always the closest transformed\n   *   ancestor or window if the element does not have any transformed\n   *   ancestors. An exception is made for browsers which allow fixed elements\n   *   to bypass the W3C specification of transform rendering. In those browsers\n   *   fixed element's containing block is always the window.\n   * - Absolute element's containing block is the closest ancestor element that\n   *   is transformed or positioned (any element which is not static), or\n   *   document if no positioned or transformed ancestor is not found.\n   * - Sticky element is a special case since \"left\", \"right\", \"top\" and\n   *   \"bottom\" CSS properties do not always affect the element's position.\n   *   However, for consistency, the closest scrolling ancestor element is\n   *   always considered as sticky element's containing block, and if no\n   *   scrolling ancestor is found window is returned.\n   * - Root element and body element are considered as equals with all other\n   *   elements and are treated equally with all other elements.\n   *\n   * @example\n   * mezr.containingBlock(elemA);\n   *\n   * @example\n   * mezr.containingBlock(elemA, 'fixed');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {String} [fakePosition]\n   *   - An optional argument which allows you to get the element's containing\n   *     block as if the element had this CSS position value applied. Using this\n   *     argument does not modify the element's true CSS position in any way,\n   *     it's only used for the calculations.\n   * @returns {?(Document|Element|Window)}\n   */\n  function getContainingBlock(el, fakePosition) {\n\n    var ret;\n    var scrollProps;\n    var parent;\n    var style;\n    var i;\n\n    // If we have document return null right away.\n    if (el === doc) {\n      return null;\n    }\n\n    // If we have window return document right away.\n    if (el === win) {\n      return doc;\n    }\n\n    // Now that we know we have an element in our hands, let's get it's\n    // position. Get element's current position value if a specific position is\n    // not provided.\n    var position = fakePosition || getStyle(el, 'position');\n\n    // Relative element's container is always the element itself.\n    if (position === 'relative') {\n      return el;\n    }\n\n    // If the element is fixed or absolute positioned.\n    else if (position === 'fixed' || position === 'absolute') {\n\n      // If the element is fixed and transforms leak fixed elements, always\n      // return window.\n      if (position === 'fixed' && settings.transformLeaksFixed) {\n        return win;\n      }\n\n      // Alrighty, so now fetch the element's parent (which is document for the\n      // root) and set it as the initial containing block. Fallback to null if\n      // everything else fails.\n      ret = el === root ? doc : el.parentElement || null;\n\n      // If element is fixed positioned: as long as the containing block is an\n      // element and is not transformed, try to get the element's parent element\n      // and fallback to document.\n      if (position === 'fixed') {\n        while (ret && ret !== doc && !isTransformed(ret)) {\n          ret = ret.parentElement || doc;\n        }\n        return ret === doc ? win : ret;\n      }\n\n      // If the element is absolute positioned: as long as the containing block\n      // is an element, is static and is not transformed, try to get the\n      // element's parent element and fallback to document.\n      else {\n        while (ret && ret !== doc && getStyle(ret, 'position') === 'static' && !isTransformed(ret)) {\n          ret = ret.parentElement || doc;\n        }\n        return ret;\n      }\n\n    }\n\n    // Sticky element's container is always the closest scrolling ancestor or\n    // window.\n    else if (position === 'sticky' || position === '-webkit-sticky') {\n\n      scrollProps = ['overflow', 'overflow-y', 'overflow-x'];\n      parent = el.parentNode;\n      el = null;\n\n      while (!el && parent && parent !== doc) {\n\n        for (i = 0; i < 3; i++) {\n          style = getStyle(parent, scrollProps[i]);\n          if (style === 'auto' || style === 'scroll') {\n            el = parent;\n            break;\n          }\n        }\n\n        if (!el) {\n          parent = parent.parentNode;\n        }\n\n      }\n\n      return el || win;\n\n    }\n\n    // If the element is static or an invalid position is provided always return\n    // null.\n    return null;\n\n  }\n\n  /**\n   * Calculate the distance between two elements or rectangles. Returns a\n   * number. If the elements/rectangles overlap the function returns -1. In\n   * other cases the function returns the distance in pixels (fractional)\n   * between the the two elements/rectangles.\n   *\n   * @example\n   * mezr.distance(elemA, elemB);\n   *\n   * @example\n   * mezr.distance([elemA, 'padding'], [elemB, 'margin']);\n\n   * @example\n   * mezr.distance(elemA, {left: 34, top: 56, width: 100, height: 200});\n   *\n   * @public\n   * @param {(Array|Document|Element|Window|Rectangle)} a\n   * @param {(Array|Document|Element|Window|Rectangle)} b\n   * @returns {Number}\n   */\n  function getDistance(a, b) {\n\n    var aRect = getSanitizedRect(a);\n    var bRect = getSanitizedRect(b);\n\n    return getIntersection(aRect, bRect) ? -1 : getDistanceBetweenRects(aRect, bRect);\n\n  }\n\n  /**\n   * Detect if all of the provided elements overlap and calculate the possible\n   * intersection area's dimensions and offsets. If the intersection area exists\n   * the function returns an object containing the intersection area's\n   * dimensions and offsets. Otherwise null is returned.\n   *\n   * @example\n   * mezr.intersection(elemA, elemB);\n   *\n   * @example\n   * mezr.intersection(elemA, [elemB, 'padding'], {\n   *   left: 0,\n   *   top: 10,\n   *   width: 100,\n   *   height: 200\n   * });\n   *\n   * @public\n   * @param {...(Array|Document|Element|Window|Rectangle)} el\n   * @returns {?Rectangle}\n   */\n  function getIntersectionMultiple() {\n\n    // Get the initial intersection of the first two items.\n    var intersection = getIntersection(arguments[0], arguments[1]);\n\n    // If there are more than two items.\n    if (arguments.length > 2) {\n\n      // Loop the arguments until the end or until the intersection is\n      // non-existent.\n      for (var i = 2; i < arguments.length; ++i) {\n        intersection = getIntersection(intersection, arguments[i]);\n        if (!intersection) {\n          break;\n        }\n      }\n\n    }\n\n    return intersection;\n\n  }\n\n  /**\n   * Calculate how much an element overflows another element per each side.\n   *\n   * @example\n   * mezr.overflow(elemA, elemB);\n   *\n   * @example\n   * mezr.overflow(elemA, [elemB, 'padding']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {Overflow}\n   */\n  function getOverflow(elA, elB) {\n\n    var ret = getOverlap(elB, elA);\n\n    return {\n      left: -ret.left,\n      right: -ret.right,\n      top: -ret.top,\n      bottom: -ret.bottom\n    };\n\n  }\n\n  /**\n   * Calculate an element's position (left/top CSS properties) when positioned\n   * relative to another element, window or the document.\n   *\n   * @example\n   * var newElementPosition = mezr.place({\n   *   element: [elemA, 'content'],\n   *   target: [elemB, 'margin'],\n   *   position: 'left top center center',\n   *   offsetX: -5,\n   *   offsetY: '50%',\n   *   contain: {\n   *     within: [elemC, 'padding'],\n   *     onOverflow: {\n   *       left: 'forcepush',\n   *       right: 'push',\n   *       top: 'none',\n   *       bottom: 'push'\n   *     }\n   *   },\n   *   adjust: function (position, data) {\n   *     position.left -= 1;\n   *     position.top += 1;\n   *   }\n   * });\n   *\n   * @public\n   * @param {PlaceOptions} options\n   * @returns {PlaceData}\n   */\n  function getPlace(options) {\n\n    var ret = {};\n    var opts = mergeObjects([settings.placeDefaultOptions, options || {}]);\n    var position = typeof opts.position === 'string' ? opts.position.split(' ') : opts.position;\n    var eRect = getSanitizedRect(opts.element, true);\n    var tRect = getSanitizedRect(opts.target);\n    var isContainDefined = isPlainObject(opts.contain);\n    var container = isContainDefined && opts.contain.within;\n    var overflowAction = isContainDefined && getOverflowAction(opts.contain.onOverflow);\n    var overflowFixLeft = 0;\n    var overflowFixTop = 0;\n    var offsetX = opts.offsetX;\n    var offsetY = opts.offsetY;\n    var cRect;\n    var overlap;\n    var eCurrentOffset;\n\n    // Sanitize offsets and check for percentage values.\n    offsetX = typeof offsetX === 'string' && offsetX.indexOf('%') > -1 ? toFloat(offsetX) / 100 * eRect.width : toFloat(offsetX);\n    offsetY = typeof offsetY === 'string' && offsetY.indexOf('%') > -1 ? toFloat(offsetY) / 100 * eRect.height : toFloat(offsetY);\n\n    // Calculate element's new position (left/top coordinates).\n    ret.left = getPlacePosition(position[0], position[2], tRect.width, tRect.left, eRect.width, eRect.left, offsetX);\n    ret.top = getPlacePosition(position[1], position[3], tRect.height, tRect.top, eRect.height, eRect.top, offsetY);\n\n    // Update element offset data to match the newly calculated position.\n    eRect.left += ret.left;\n    eRect.top += ret.top;\n\n    // If container element and overflow action are defined, let's handle\n    // container's possible overflow.\n    if (container && overflowAction) {\n\n      // Get container rect and overlap data.\n      cRect = getSanitizedRect(container);\n      overlap = getOverlap(eRect, cRect);\n\n      // Handle horizontal overflow.\n      if (overlap.left < 0 || overlap.right < 0) {\n        overflowFixLeft = getPlaceOverflowPush(overflowAction, overlap);\n        ret.left += overflowFixLeft;\n      }\n\n      // Handle vertical overflow.\n      if (overlap.top < 0 || overlap.bottom < 0) {\n        overflowFixTop = getPlaceOverflowPush(overflowAction, overlap, 1);\n        ret.top += overflowFixTop;\n      }\n\n    }\n\n    if (typeof opts.adjust === 'function') {\n\n      // Update element's left and right rect data to account for the possible\n      // overflow correction.\n      if (overflowFixLeft !== 0) {\n        eRect.left += overflowFixLeft;\n        eRect.right = eRect.left + eRect.width;\n      }\n\n      // Update element's top and bottom rect data to account for the possible\n      // overflow correction.\n      if (overflowFixTop !== 0) {\n        eRect.top += overflowFixTop;\n        eRect.bottom = eRect.left + eRect.width;\n      }\n\n      // Get container rect.\n      cRect = container ? cRect || getSanitizedRect(container) : null;\n\n      // Get the element's current offset so we can calculate how much the\n      // element moved.\n      eCurrentOffset = isPlainObject(opts.element) ? opts.element : getOffsetFromDocument.apply(null, [].concat(opts.element));\n\n      // Calculate overlap data based on the new position.\n      overlap = cRect ? getOverlap(eRect, cRect) : null;\n\n      // Provide the final position hash as the first argument (which can be\n      // modified and it affects the return value of this method) and all the\n      // positioning data as the second argument.\n      opts.adjust(ret, {\n        elementRect: eRect,\n        targetRect: tRect,\n        containerRect: cRect,\n        shift: {\n          left: eRect.left - eCurrentOffset.left,\n          top: eRect.top - eCurrentOffset.top\n        },\n        overflow: !overlap ? null : {\n          left: -overlap.left,\n          right: -overlap.right,\n          top: -overlap.top,\n          bottom: -overlap.bottom\n        },\n        overflowCorrection: {\n          left: overflowFixLeft,\n          top: overflowFixTop\n        }\n      });\n\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Private helper functions\n   * ************************\n   */\n\n  /**\n   * Check if a value is a plain object.\n   *\n   * @private\n   * @param {*} val\n   * @returns {Boolean}\n   */\n  function isPlainObject(val) {\n\n    return typeof val === 'object' && Object.prototype.toString.call(val) === '[object Object]';\n\n  }\n\n  /**\n   * Returns the supported transform property's prefix, property name and style\n   * name or null if transforms are not supported.\n   *\n   * @private\n   * @returns {?Object}\n   */\n  function getSupportedTransform() {\n\n    var transforms = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform'];\n\n    for (var i = 0; i < transforms.length; i++) {\n      if (root.style[transforms[i]] !== undefined) {\n\n        var prop = transforms[i];\n        var prefix = prop.toLowerCase().split('transform')[0];\n\n        return {\n          prefix: prefix,\n          propName: prop,\n          styleName: prefix ? '-' + prefix + '-transform' : prop\n        };\n\n      }\n    }\n\n    return null;\n\n  }\n\n  /**\n   * Detects if transformed elements leak fixed elements. According W3C\n   * transform rendering spec a transformed element should contain even fixed\n   * elements. Meaning that fixed elements are positioned relative to the\n   * closest transformed ancestor element instead of window. However, not every\n   * browser follows the spec (IE and older Firefox), so we need to test it.\n   * https://www.w3.org/TR/css3-2d-transforms/#transform-rendering\n   *\n   * @private\n   * @returns {Boolean}\n   *   - Returns true if transformed elements leak fixed elements, false\n   *     otherwise.\n   */\n  function doesTransformLeakFixed() {\n\n    if (!settings.transform) {\n      return true;\n    }\n\n    var outer = doc.createElement('div');\n    var inner = doc.createElement('div');\n    var leftNotTransformed;\n    var leftTransformed;\n\n    setStyles(outer, {\n      display: 'block',\n      visibility: 'hidden',\n      position: 'absolute',\n      width: '1px',\n      height: '1px',\n      left: '1px',\n      top: '0',\n      margin: '0'\n    });\n\n    setStyles(inner, {\n      display: 'block',\n      position: 'fixed',\n      width: '1px',\n      height: '1px',\n      left: '0',\n      top: '0',\n      margin: '0'\n    });\n\n    outer.appendChild(inner);\n    body.appendChild(outer);\n    leftNotTransformed = inner.getBoundingClientRect().left;\n    outer.style[settings.transform.propName] = 'translateX(0)';\n    leftTransformed = inner.getBoundingClientRect().left;\n    body.removeChild(outer);\n\n    return leftTransformed === leftNotTransformed;\n\n  }\n\n  /**\n   * Returns true if element is transformed, false if not. In practice the\n   * element's display value must be anything else than \"none\" or \"inline\" as\n   * well as have a valid transform value applied in order to be counted as a\n   * transformed element.\n   *\n   * @private\n   * @param {Element} el\n   * @returns {Boolean}\n   */\n  function isTransformed(el) {\n\n    var transform = getStyle(el, settings.transform.styleName);\n    var display = getStyle(el, 'display');\n\n    return transform !== 'none' && display !== 'inline' && display !== 'none';\n\n  }\n\n  /**\n   * Customized parseFloat function which returns 0 instead of NaN.\n   *\n   * @private\n   * @param {Number|String} val\n   * @returns {Number}\n   */\n  function toFloat(val) {\n\n    return parseFloat(val) || 0;\n\n  }\n\n  /**\n   * Deep merge an array of objects into a new object.\n   *\n   * @private\n   * @param {Array} array\n   * @returns {Object}\n   */\n  function mergeObjects(array) {\n\n    var ret = {};\n    var propName;\n    var propVal;\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      for (propName in array[i]) {\n        if (array[i].hasOwnProperty(propName)) {\n          propVal = array[i][propName];\n          ret[propName] = isPlainObject(propVal) ? mergeObjects([propVal]) :\n                          Array.isArray(propVal) ? propVal.slice() :\n                                                   propVal;\n        }\n      }\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns the computed value of an element's style property as a string.\n   *\n   * @private\n   * @param {Element} el\n   * @param {String} style\n   * @returns {String}\n   */\n  function getStyle(el, style) {\n\n    return win.getComputedStyle(el, null).getPropertyValue(style);\n\n  }\n\n  /**\n   * Returns the computed value of an element's style property transformed into\n   * a float value.\n   *\n   * @private\n   * @param {Element} el\n   * @param {String} style\n   * @returns {Number}\n   */\n  function getStyleAsFloat(el, style) {\n\n    return toFloat(getStyle(el, style));\n\n  }\n\n  /**\n   * Set inline styles to an element.\n   *\n   * @private\n   * @param {Element} el\n   * @param {Object} styles\n   */\n  function setStyles(el, styles) {\n\n    Object.keys(styles).forEach(function (styleName) {\n      el.style[styleName] = styles[styleName];\n    });\n\n  }\n\n  /**\n   * Calculates how much element overlaps another element from each side.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {Overlap}\n   */\n  function getOverlap(elA, elB) {\n\n    var aRect = getSanitizedRect(elA);\n    var bRect = getSanitizedRect(elB);\n\n    return {\n      left: aRect.left - bRect.left,\n      right: (bRect.left + bRect.width) - (aRect.left + aRect.width),\n      top: aRect.top - bRect.top,\n      bottom: (bRect.top + bRect.height) - (aRect.top + aRect.height)\n    };\n\n  }\n\n  /**\n   * Detect if two elements overlap and calculate the possible intersection\n   * area's dimensions and offsets. If the intersection area exists the function\n   * returns an object containing the intersection area's dimensions and\n   * offsets. Otherwise null is returned.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {?RectangleExtended}\n   */\n  function getIntersection(elA, elB) {\n\n    var ret = {};\n    var aRect = getSanitizedRect(elA);\n    var bRect = getSanitizedRect(elB);\n    var overlap = getOverlap(aRect, bRect);\n    var intWidth = max(aRect.width + min(overlap.left, 0) + min(overlap.right, 0), 0);\n    var intHeight = max(aRect.height + min(overlap.top, 0) + min(overlap.bottom, 0), 0);\n    var hasIntersection = intWidth > 0 && intHeight > 0;\n\n    if (hasIntersection) {\n      ret.width = intWidth;\n      ret.height = intHeight;\n      ret.left = aRect.left + abs(min(overlap.left, 0));\n      ret.top = aRect.top + abs(min(overlap.top, 0));\n      ret.right = ret.left + ret.width;\n      ret.bottom = ret.top + ret.height;\n    }\n\n    return hasIntersection ? ret : null;\n\n  }\n\n  /**\n   * Calculates the distance between two points in 2D space.\n   *\n   * @private\n   * @param {Number} aLeft\n   * @param {Number} aTop\n   * @param {Number} bLeft\n   * @param {Number} bTop\n   * @returns {Number}\n   */\n  function getDistanceBetweenPoints(aLeft, aTop, bLeft, bTop) {\n\n    return Math.sqrt(Math.pow(bLeft - aLeft, 2) + Math.pow(bTop - aTop, 2));\n\n  }\n\n  /**\n   * Calculates the distance between two unrotated rectangles in 2D space. This\n   * function assumes that the rectangles do not intersect.\n   *\n   * @private\n   * @param {Rectangle} rectA\n   * @param {Rectangle} rectB\n   * @returns {Number}\n   */\n  function getDistanceBetweenRects(rectA, rectB) {\n\n    var ret = 0;\n    var aLeft = rectA.left;\n    var aRight = aLeft + rectA.width;\n    var aTop = rectA.top;\n    var aBottom = aTop + rectA.height;\n    var bLeft = rectB.left;\n    var bRight = bLeft + rectB.width;\n    var bTop = rectB.top;\n    var bBottom = bTop + rectB.height;\n\n    // Calculate shortest corner distance\n    if ((bLeft > aRight || bRight < aLeft) && (bTop > aBottom || bBottom < aTop)) {\n      if (bLeft > aRight) {\n        ret = bBottom < aTop ? getDistanceBetweenPoints(aRight, aTop, bLeft, bBottom) : getDistanceBetweenPoints(aRight, aBottom, bLeft, bTop);\n      }\n      else {\n        ret = bBottom < aTop ? getDistanceBetweenPoints(aLeft, aTop, bRight, bBottom) : getDistanceBetweenPoints(aLeft, aBottom, bRight, bTop);\n      }\n    }\n\n    // Calculate shortest edge distance\n    else {\n      ret = bBottom < aTop ? aTop - bBottom :\n            bLeft > aRight ? bLeft - aRight :\n            bTop > aBottom ? bTop - aBottom :\n            aLeft - bRight;\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns the height/width of an element in pixels. The function also accepts\n   * the window object (for obtaining the viewport dimensions) and the document\n   * object (for obtaining the dimensions of the document) in place of element.\n   * Note that this function considers root element's scrollbars as the\n   * document's and window's scrollbars also. Since the root element's\n   * scrollbars are always stuck on the right/bottom edge of the window (even if\n   * you specify width and/or height to root element) they are generally\n   * referred to as viewport scrollbars in the docs. Also note that only\n   * positive margins are included in the result when includeMargin argument is\n   * true.\n   *\n   * @private\n   * @param {String} dimension\n   *   - Accepts \"width\" or \"height\".\n   * @param {(Document|Element|Window)} el\n   * @param {Boolean} [includePadding=false]\n   * @param {Boolean} [includeScrollbar=false]\n   * @param {Boolean} [includeBorder=false]\n   * @param {Boolean} [includeMargin=false]\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getDimension(dimension, el, includePadding, includeScrollbar, includeBorder, includeMargin) {\n\n    var ret;\n    var isHeight = dimension === 'height';\n    var dimensionCapitalized = isHeight ? 'Height' : 'Width';\n    var innerDimension = 'inner' + dimensionCapitalized;\n    var clientDimension = 'client' + dimensionCapitalized;\n    var scrollDimension = 'scroll' + dimensionCapitalized;\n    var sbSize = 0;\n    var edgeA;\n    var edgeB;\n    var borderA;\n    var borderB;\n    var marginA;\n    var marginB;\n\n    if (el.self === win.self) {\n\n      ret = includeScrollbar ? win[innerDimension] : root[clientDimension];\n\n    }\n    else if (el === doc) {\n\n      if (includeScrollbar) {\n        sbSize = win[innerDimension] - root[clientDimension];\n        ret = max(root[scrollDimension] + sbSize, body[scrollDimension] + sbSize, win[innerDimension]);\n      }\n      else {\n        ret = max(root[scrollDimension], body[scrollDimension], root[clientDimension]);\n      }\n\n    }\n    else {\n\n      edgeA = isHeight ? 'top' : 'left';\n      edgeB = isHeight ? 'bottom' : 'right';\n      ret = (tempBCR || el.getBoundingClientRect())[dimension];\n\n      if (!includeScrollbar) {\n\n        if (el === root) {\n          sbSize = win[innerDimension] - root[clientDimension];\n        }\n        else if (unscrollableDisplayValues.indexOf(getStyle(el, 'display')) < 0) {\n          borderA = getStyleAsFloat(el, 'border-' + edgeA + '-width');\n          borderB = getStyleAsFloat(el, 'border-' + edgeB + '-width');\n          sbSize = Math.round(ret) - (el[clientDimension] + borderA + borderB);\n        }\n\n        ret -= sbSize > 0 ? sbSize : 0;\n\n      }\n\n      if (!includePadding) {\n        ret -= getStyleAsFloat(el, 'padding-' + edgeA);\n        ret -= getStyleAsFloat(el, 'padding-' + edgeB);\n      }\n\n      if (!includeBorder) {\n        ret -= borderA !== undefined ? borderA : getStyleAsFloat(el, 'border-' + edgeA + '-width');\n        ret -= borderB !== undefined ? borderB : getStyleAsFloat(el, 'border-' + edgeB + '-width');\n      }\n\n      if (includeMargin) {\n        marginA = getStyleAsFloat(el, 'margin-' + edgeA);\n        marginB = getStyleAsFloat(el, 'margin-' + edgeB);\n        ret += marginA > 0 ? marginA : 0;\n        ret += marginB > 0 ? marginB : 0;\n      }\n\n    }\n\n    return ret > 0 ? ret : 0;\n\n  }\n\n  /**\n   * Returns the element's (or window's) document offset, which in practice\n   * means the vertical and horizontal distance between the element's northwest\n   * corner and the document's northwest corner.\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Offset}\n   */\n  function getOffsetFromDocument(el, edge) {\n\n    var ret = {\n      left: 0,\n      top: 0\n    };\n\n    // Document's offsets are always 0.\n    if (el === doc) {\n      return ret;\n    }\n\n    // Add viewport's scroll left/top to the respective offsets.\n    ret.left = win.pageXOffset || 0;\n    ret.top = win.pageYOffset || 0;\n\n    // Window's offsets are the viewport's scroll left/top values.\n    if (el.self === win.self) {\n      return ret;\n    }\n\n    // Now we know we are calculating an element's offsets so let's first get\n    // the element's bounding client rect. If it is not cached, then just fetch\n    // it.\n    var gbcr = tempBCR || el.getBoundingClientRect();\n\n    // Add bounding client rect's left/top values to the offsets.\n    ret.left += gbcr.left;\n    ret.top += gbcr.top;\n\n    // Sanitize edge.\n    edge = edge && edges[edge] || 4;\n\n    // Exclude element's positive margin size from the offset if needed.\n    if (edge === 5) {\n      var marginLeft = getStyleAsFloat(el, 'margin-left');\n      var marginTop = getStyleAsFloat(el, 'margin-top');\n      ret.left -= marginLeft > 0 ? marginLeft : 0;\n      ret.top -= marginTop > 0 ? marginTop : 0;\n    }\n\n    // Include element's border size to the offset if needed.\n    if (edge < 4) {\n      ret.left += getStyleAsFloat(el, 'border-left-width');\n      ret.top += getStyleAsFloat(el, 'border-top-width');\n    }\n\n    // Include element's padding size to the offset if needed.\n    if (edge === 1) {\n      ret.left += getStyleAsFloat(el, 'padding-left');\n      ret.top += getStyleAsFloat(el, 'padding-top');\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically just a wrapper for the getRectInternal function which\n   * does some argument normalization before doing the actal calculations. Used\n   * only internally.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} el\n   * @param {Boolean} [useStaticOffset=false]\n   * @returns {?Rectangle}\n   */\n  function getSanitizedRect(el, useStaticOffset) {\n\n    // Can't have an empty value.\n    if (!el) {\n      return null;\n    }\n\n    // Let's assume that plain objects are static rectangle definitions.\n    if (isPlainObject(el)) {\n      return el;\n    }\n\n    // We don't know for sure if the provided element is defined with an edge\n    // layer (array syntax) or not. So let's play it safe an normalize the value\n    // to an array.\n    el = [].concat(el);\n\n    return getRectInternal(el[0], el[1], useStaticOffset);\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically a helper method for calculating an element's dimensions\n   * and offsets simultaneously. Mimics the native getBoundingClientRect method\n   * with the added bonus of allowing to provide the \"edge\" of the element.\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @param {Boolean} [useStaticOffset=false]\n   * @returns {Rectangle}\n   */\n  function getRectInternal(el, edge, useStaticOffset) {\n\n    var isElem = el !== doc && el.self !== win.self;\n    var rect;\n\n    // Sanitize edge.\n    edge = edge || 'border';\n\n    // If static offset is required we have to get it before temporary bounding\n    // client rect is cached, since it might need to get the offset of another\n    // element than the cached one.\n    if (useStaticOffset) {\n      rect = getStaticOffset(el, edge);\n    }\n\n    // Cache element's bounding client rect.\n    if (isElem) {\n      tempBCR = el.getBoundingClientRect();\n    }\n\n    // If static offset is not required we know for sure that the temporary\n    // bounding client rect is the same element we need to get offset for.\n    if (!useStaticOffset) {\n      rect = getOffsetFromDocument(el, edge);\n    }\n\n    // Get element's width and height.\n    rect.width = getWidth(el, edge);\n    rect.height = getHeight(el, edge);\n\n    // Calculate element's bottom and right.\n    rect.bottom = rect.top + rect.height;\n    rect.right = rect.left + rect.width;\n\n    // Nullify temporary bounding client rect cache.\n    if (isElem) {\n      tempBCR = null;\n    }\n\n    return rect;\n\n  }\n\n  /**\n   * Returns an element's static offset which in this case means the element's\n   * offset in a state where the element's left and top CSS properties are set\n   * to 0.\n   *\n   * @private\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} edge\n   * @returns {Offset}\n   */\n  function getStaticOffset(el, edge) {\n\n    // Sanitize edge.\n    edge = edge || 'border';\n\n    // For window and document just return normal offset.\n    if (el === win || el === doc) {\n      return getOffsetFromDocument(el, edge);\n    }\n\n    var position = getStyle(el, 'position');\n    var offset = position === 'absolute' || position === 'fixed' ? getOffsetFromDocument(getContainingBlock(el) || doc, 'padding') : getOffsetFromDocument(el, edge);\n\n    if (position === 'relative') {\n\n      var left = getStyle(el, 'left');\n      var right = getStyle(el, 'right');\n      var top = getStyle(el, 'top');\n      var bottom = getStyle(el, 'bottom');\n\n      if (left !== 'auto' || right !== 'auto') {\n        offset.left -= left === 'auto' ? -toFloat(right) : toFloat(left);\n      }\n\n      if (top !== 'auto' || bottom !== 'auto') {\n        offset.top -= top === 'auto' ? -toFloat(bottom) : toFloat(top);\n      }\n\n    }\n    else if (position === 'absolute' || position === 'fixed') {\n\n      // Get edge number.\n      edge = edges[edge];\n\n      // Get left and top margins.\n      var marginLeft = getStyleAsFloat(el, 'margin-left');\n      var marginTop = getStyleAsFloat(el, 'margin-top');\n\n      // If edge is \"margin\" remove negative left/top margins from offset to\n      // account for their effect on position.\n      if (edge === 5) {\n        offset.left -= abs(min(marginLeft, 0));\n        offset.top -= abs(min(marginTop, 0));\n      }\n\n      // If edge is \"border\" or smaller add positive left/top margins and remove\n      // negative left/top margins from offset to account for their effect on\n      // position.\n      if (edge < 5) {\n        offset.left += marginLeft;\n        offset.top += marginTop;\n      }\n\n      // If edge is \"scroll\" or smaller add left/top borders to offset to\n      // account for their effect on position.\n      if (edge < 4) {\n        offset.left += getStyleAsFloat(el, 'border-left-width');\n        offset.top += getStyleAsFloat(el, 'border-top-width');\n      }\n\n      // If edge is \"content\" add left/top paddings to offset to account for\n      // their effect on position.\n      if (edge === 1) {\n        offset.left += getStyleAsFloat(el, 'padding-left');\n        offset.top += getStyleAsFloat(el, 'padding-top');\n      }\n\n    }\n\n    return offset;\n\n  }\n\n  /**\n   * Returns the horizontal or vertical base position of an element relative to\n   * the target element. In other words, this function returns the left and top\n   * CSS values which should be set as to the target element in order to\n   * position it according to the desired position.\n   *\n   * @private\n   * @param {String} elementPosition\n   *   - Element's position: \"left\", \"right\", \"top\", \"bottom\" or \"center\".\n   * @param {String} targetPosition\n   *   - Target's position: \"left\", \"right\", \"top\", \"bottom\" or \"center\".\n   * @param {Number} targetSize\n   *   - Target's width/height in pixels.\n   * @param {Number} targetOffset\n   *   - Target's left/top offset in pixels.\n   * @param {Number} elementSize\n   *   - Element's width/height in pixels.\n   * @param {Number} elementNwOffset\n   *   - Element's left/top northwest offset in pixels.\n   * @param {Number} extraOffset\n   *   - Additional left/top offset in pixels.\n   * @returns {Number}\n   */\n  function getPlacePosition(elementPosition, targetPosition, targetSize, targetOffset, elementSize, elementNwOffset, extraOffset) {\n\n    var placement = elementPosition.charAt(0) + targetPosition.charAt(0);\n    var northwestPoint = targetOffset + extraOffset - elementNwOffset;\n\n    return placement === 'll' || placement === 'tt' ? northwestPoint :\n           placement === 'lc' || placement === 'tc' ? northwestPoint + (targetSize / 2) :\n           placement === 'lr' || placement === 'tb' ? northwestPoint + targetSize :\n           placement === 'cl' || placement === 'ct' ? northwestPoint - (elementSize / 2) :\n           placement === 'cr' || placement === 'cb' ? northwestPoint + targetSize - (elementSize / 2) :\n           placement === 'rl' || placement === 'bt' ? northwestPoint - elementSize :\n           placement === 'rc' || placement === 'bc' ? northwestPoint - elementSize + (targetSize / 2) :\n           placement === 'rr' || placement === 'bb' ? northwestPoint - elementSize + targetSize :\n                                                      northwestPoint + (targetSize / 2) - (elementSize / 2);\n\n  }\n\n  /**\n   * Calculates the distance in pixels that the element needs to be moved in\n   * order to be aligned correctly if the target element overlaps the container.\n   *\n   * @private\n   * @param {OverflowConfig} overflowConfig\n   * @param {Overlap} targetOverlap\n   * @param {Boolean} isVertical\n   * @returns {Number}\n   */\n  function getPlaceOverflowPush(overflowConfig, targetOverlap, isVertical) {\n\n    var ret = 0;\n    var push = 'push';\n    var forcePush = 'forcepush';\n    var sideA = isVertical ? 'top' : 'left';\n    var sideB = isVertical ? 'bottom' : 'right';\n    var sideAConfig = overflowConfig[sideA];\n    var sideBConfig = overflowConfig[sideB];\n    var sideAOverlap = targetOverlap[sideA];\n    var sideBOverlap = targetOverlap[sideB];\n    var sizeDifference = sideAOverlap + sideBOverlap;\n\n    // If pushing is needed from both sides.\n    if ((sideAConfig === push || sideAConfig === forcePush) && (sideBConfig === push || sideBConfig === forcePush) && (sideAOverlap < 0 || sideBOverlap < 0)) {\n\n      // Do push correction from opposite sides with equal force.\n      if (sideAOverlap < sideBOverlap) {\n        ret -= sizeDifference < 0 ? sideAOverlap + abs(sizeDifference / 2) : sideAOverlap;\n      }\n\n      // Do push correction from opposite sides with equal force.\n      if (sideBOverlap < sideAOverlap) {\n        ret += sizeDifference < 0 ? sideBOverlap + abs(sizeDifference / 2) : sideBOverlap;\n      }\n\n      // Update overlap data.\n      sideAOverlap += ret;\n      sideBOverlap -= ret;\n\n      // Check if left/top side forced push correction is needed.\n      if (sideAConfig === forcePush && sideBConfig !== forcePush && sideAOverlap < 0) {\n        ret -= sideAOverlap;\n      }\n\n      // Check if right/top side forced push correction is needed.\n      if (sideBConfig === forcePush && sideAConfig !== forcePush && sideBOverlap < 0) {\n        ret += sideBOverlap;\n      }\n\n    }\n\n    // Check if pushing is needed from left or top side only.\n    else if ((sideAConfig === forcePush || sideAConfig === push) && sideAOverlap < 0) {\n      ret -= sideAOverlap;\n    }\n\n    // Check if pushing is needed from right or bottom side only.\n    else if ((sideBConfig === forcePush || sideBConfig === push) && sideBOverlap < 0) {\n      ret += sideBOverlap;\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Sanitize contain.onOverflow option of .place() method.\n   *\n   * @private\n   * @param {OverflowConfig} overflowConfig\n   * @returns {?overflowConfigSanitized}\n   */\n  function getOverflowAction(overflowConfig) {\n\n    var actionType = typeof overflowConfig;\n    var left = 'none';\n    var right = 'none';\n    var top = 'none';\n    var bottom = 'none';\n\n    // onOverflow string value is always used for all sides.\n    if (actionType === 'string') {\n      left = right = top = bottom = overflowConfig;\n    }\n\n    // onOverflow object value can have properties that present a side\n    // (left/right/top/bottom) or an axis (x/y). Always try to use the side\n    // value first and then fallback to axis value. If all else fails fallback\n    // to \"none\".\n    else if (actionType === 'object') {\n      left = overflowConfig.left || overflowConfig.x || left;\n      right = overflowConfig.right || overflowConfig.x || right;\n      top = overflowConfig.top || overflowConfig.y || top;\n      bottom = overflowConfig.bottom || overflowConfig.y || bottom;\n    }\n\n    // If one side (or more) has a value other than \"none\" we know that the\n    // contain option might have an effect on the positioning.\n    if (left !== 'none' || right !== 'none' || top !== 'none' || bottom !== 'none') {\n      return {\n        left: left,\n        right: right,\n        top: top,\n        bottom: bottom\n      };\n    }\n\n    return null;\n\n  }\n\n  /**\n   * Custom type definitions\n   * ***********************\n   */\n\n  /**\n   * The browser's window object.\n   *\n   * @typedef {Object} Window\n   */\n\n  /**\n   * The document contained in browser's window object.\n   *\n   * @typedef {Object} Document\n   */\n\n  /**\n   * Any HTML element including root and body elements.\n   *\n   * @typedef {Object} Element\n   */\n\n  /**\n   * The name of an element's box model edge which allows you to decide which\n   * areas of the element you want to include in the calculations. Valid edge\n   * values are \"content\", \"padding\", \"scroll\", \"border\" and \"margin\", in that\n   * specific order. Note that \"scroll\" is not a valid element edge accroding to\n   * W3C spec, but it is used here to define whether or not the scrollbar's size\n   * should be included in the calculations. For window and document objects\n   * this argument behaves a bit differently since they cannot have any\n   * paddings, borders or margins. Only \"content\" (without vertical scrollbar’s\n   * width) and \"scroll\" (with vertical scrollbar’s width) are effective values.\n   * \"padding\" is normalized to \"content\" while \"border\" and \"margin\" are\n   * normalized to \"scroll\".\n   *\n   * @typedef {String} Edge\n   */\n\n  /**\n   * @typedef {Object} Rectangle\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document.\n   * @property {Number} height\n   *   - Element's height.\n   * @property {Number} width\n   *   - Element's width.\n   */\n\n  /**\n   * @typedef {Object} RectangleExtended\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document.\n   * @property {Number} right\n   *   - Element's horizontal distance from the left edge of the document plus\n   *     width.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document\n   * @property {Number} bottom\n   *   - Element's vertical distance from the top edge of the document plus\n   *     height.\n   * @property {Number} height\n   *   - Element's height.\n   * @property {Number} width\n   *   - Element's width.\n   */\n\n  /**\n   * @typedef {Object} Offset\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document,\n   *     window or other element.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document, window,\n   *     or other element.\n   */\n\n  /**\n   * @typedef {Object} Overlap\n   * @property {Number} left\n   * @property {Number} top\n   * @property {Number} right\n   * @property {Number} bottom\n   */\n\n  /**\n   * @typedef {Object} Overflow\n   * @property {Number} left\n   * @property {Number} top\n   * @property {Number} right\n   * @property {Number} bottom\n   */\n\n  /**\n   * @typedef {Object} PlaceOptions\n   * @param {(Array|Document|Element|Window|Rectangle)} element\n   * @property {(Array|Document|Element|Window|Rectangle)} target\n   * @property {PlaceOptionsPosition} [position='left top left top']\n   * @property {Number} [offsetX=0]\n   * @property {Number} [offsetY=0]\n   * @property {?PlaceOptionsContainment} [contain=null]\n   */\n\n  /**\n   * Raw positioning data for position option of .place() method.\n   * String syntax: \"elemX elemY targetX targetY\".\n   * Array syntax: [\"elemX\", \"elemY\", \"targetX\", \"targetY\"].\n   * Possible values for elemX and targetX: \"left\", \"center\", \"right\".\n   * Possible values for elemY and targetY: \"top\", \"center\", \"bottom\".\n   *\n   * @typedef {(Array|String)} PlaceOptionsPosition\n   */\n\n  /**\n   * All properties accepts the following values: \"push\", \"forcepush\" and\n   * \"none\".\n   *\n   * @typedef {Object} PlaceOptionsContainment\n   * @property {?(Array|Document|Element|Window|Rectangle)} within\n   * @property {?(OverflowConfig|String)} onOverflow\n   */\n\n  /**\n   * All properties accepts the following values: \"push\", \"forcepush\" and\n   * \"none\". The properties left, right, top and bottom are used to define the\n   * overflow action that should be called when the positioned element overflows\n   * the container element from the respective side. Alternatively you can also\n   * use the properties x and y to define the overflow action per axis. If you\n   * mix side overflow properties with axis overflow properties remember that\n   * the side configuration overwrites the axis configuration.\n   *\n   * @typedef {Object} OverflowConfig\n   * @property {String} [left='none']\n   * @property {String} [right='none']\n   * @property {String} [top='none']\n   * @property {String} [bottom='none']\n   * @property {String} [x='none']\n   * @property {String} [y='none']\n   */\n\n  /**\n   * A sanitized configuration data object for contain.onOverflow option of\n   * .place() method.\n   *\n   * @typedef {Object} OverflowConfigSanitized\n   * @property {String} left\n   * @property {String} right\n   * @property {String} top\n   * @property {String} bottom\n   */\n\n  /**\n   * @typedef {Object} PlaceData\n   * @property {Number} left\n   *   - Target element's new left position.\n   * @property {Number} top\n   *   - Target element's new top position.\n   */\n\n  // Name and return the public methods.\n  return {\n    width: getWidth,\n    height: getHeight,\n    offset: getOffset,\n    rect: getRect,\n    containingBlock: getContainingBlock,\n    distance: getDistance,\n    intersection: getIntersectionMultiple,\n    overflow: getOverflow,\n    place: getPlace,\n    _settings: settings\n  };\n\n}));\n"],"sourceRoot":""}